<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Kaguyacraft build 0.0.3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #80a0ff; font-family: sans-serif; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; pointer-events: none; z-index: 10; }
        #hand { position: absolute; bottom: -20px; right: 15%; width: 200px; pointer-events: none; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 2px 2px #000; }
    </style>
</head>
<body>
    <div id="ui">Kaguyacraft build 0.0.3</div>
    <div id="crosshair">+</div>
    <img id="hand" src="https://i.imgur.com/8kX5p8v.png">

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURAÇÃO ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x80a0ff);
        scene.fog = new THREE.Fog(0x80a0ff, 30, 80);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(light);

        // --- MUNDO EXPANDIDO (60x60) ---
        const mapSize = 60;
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x59c030 });
        const stoneMat = new THREE.MeshLambertMaterial({ color: 0x808080 });

        for(let x = -mapSize/2; x < mapSize/2; x++) {
            for(let z = -mapSize/2; z < mapSize/2; z++) {
                const h = Math.floor(Math.sin(x/8) * Math.cos(z/8) * 4) + 3;
                for(let y = 0; y < h; y++) {
                    const cube = new THREE.Mesh(boxGeo, y === h-1 ? grassMat : stoneMat);
                    cube.position.set(x, y, z);
                    scene.add(cube);
                }
            }
        }

        // --- ESQUELETOS E IA ---
        const skeletons = [];
        const arrows = [];
        const skelGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6);
        const skelMat = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });

        function spawnSkeleton(x, z) {
            const skel = new THREE.Mesh(skelGeo, skelMat);
            skel.position.set(x, 5, z);
            skel.userData = { lastShot: 0 };
            scene.add(skel);
            skeletons.push(skel);
        }

        spawnSkeleton(10, 10);
        spawnSkeleton(-15, 5);
        spawnSkeleton(5, -15);

        // --- FLECHAS ---
        const arrowGeo = new THREE.BoxGeometry(0.1, 0.1, 0.5);
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0x555555 });

        function fireArrow(from, target) {
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.copy(from);
            arrow.lookAt(target);
            const dir = new THREE.Vector3().subVectors(target, from).normalize();
            arrow.userData = { velocity: dir.multiplyScalar(0.3) };
            scene.add(arrow);
            arrows.push(arrow);
        }

        // --- CONTROLES ---
        let keys = {};
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);
        window.onclick = () => document.body.requestPointerLock();

        camera.position.set(0, 10, 0);

        function update() {
            // Movimento Player
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            if(keys['KeyW']) camera.position.addScaledVector(dir, 0.15);
            if(keys['KeyS']) camera.position.addScaledVector(dir, -0.15);

            // IA dos Esqueletos
            skeletons.forEach(s => {
                s.lookAt(camera.position.x, s.position.y, camera.position.z);
                const dist = s.position.distanceTo(camera.position);
                
                // Atira se estiver perto (menos de 20 blocos) a cada 2 segundos
                if(dist < 20 && Date.now() - s.userData.lastShot > 2000) {
                    fireArrow(s.position.clone(), camera.position.clone());
                    s.userData.lastShot = Date.now();
                }
            });

            // Movimento das Flechas
            arrows.forEach((a, i) => {
                a.position.add(a.userData.velocity);
                if(a.position.distanceTo(camera.position) < 0.5) {
                    console.log("Dano!"); // Aqui você pode adicionar sistema de vida
                }
                if(a.position.y < -5) { scene.remove(a); arrows.splice(i, 1); }
            });

            renderer.render(scene, camera);
            requestAnimationFrame(update);
        }

        document.addEventListener('mousemove', e => {
            if(document.pointerLockElement === document.body) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }
        });

        camera.rotation.order = 'YXZ';
        update();
    </script>
</body>
</html>
