<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; pointer-events: none; z-index: 10; font-weight: 100; }
        #hotbar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; background: rgba(0,0,0,0.6); padding: 5px; border: 4px solid #333; }
        .slot { width: 50px; height: 50px; border: 4px solid #888; margin: 2px; display: flex; justify-content: center; align-items: center; background-size: cover; image-rendering: pixelated; }
        .slot.selected { border-color: white; box-shadow: 0 0 10px white; }
        #debug { position: absolute; top: 10px; left: 10px; color: white; font-size: 12px; text-shadow: 1px 1px black; }
    </style>
</head>
<body>
    <div id="debug">Minecraft Alpha v0.1.0<br>Chunks: 16x16</div>
    <div id="crosshair">+</div>
    <div id="hotbar" id="inventory"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- ENGINE DE SOM (Sintetizador) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playPopSound(freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.1);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }

        // --- SETUP CENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x80a0ff);
        scene.fog = new THREE.Fog(0x80a0ff, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- TEXTURAS ALPHA ---
        const loader = (c1, c2) => {
            const can = document.createElement('canvas'); can.width = 16; can.height = 16;
            const ctx = can.getContext('2d'); ctx.fillStyle = c1; ctx.fillRect(0,0,16,16);
            ctx.fillStyle = c2; for(let i=0;i<64;i++) ctx.fillRect(Math.random()*16, Math.random()*16, 2, 2);
            const tex = new THREE.CanvasTexture(can); tex.magFilter = THREE.NearestFilter; return tex;
        };

        const mats = {
            1: new THREE.MeshLambertMaterial({ map: loader('#59c030', '#458b22') }), // Grama
            2: new THREE.MeshLambertMaterial({ map: loader('#866043', '#503521') }), // Terra
            3: new THREE.MeshLambertMaterial({ map: loader('#7a7a7a', '#5a5a5a') }), // Pedra
            4: new THREE.MeshLambertMaterial({ map: loader('#5d422a', '#332314') }), // Madeira
            5: new THREE.MeshLambertMaterial({ map: loader('#2d5d22', '#1a3614'), transparent: true, opacity: 0.9 }) // Folhas
        };

        // --- GERAÇÃO DE MUNDO ---
        const world = [];
        const size = 32;
        const box = new THREE.BoxGeometry(1, 1, 1);
        
        for(let x=0; x<size; x++) {
            for(let z=0; z<size; z++) {
                const h = Math.floor(Math.sin(x/4)*Math.cos(z/4)*3) + 5;
                for(let y=0; y<h; y++) {
                    let type = y === h-1 ? 1 : (y > h-3 ? 2 : 3);
                    const mesh = new THREE.Mesh(box, mats[type]);
                    mesh.position.set(x-size/2, y, z-size/2);
                    mesh.userData = { type };
                    scene.add(mesh); world.push(mesh);
                }
                // Chance de árvore
                if(Math.random() > 0.96 && h > 0) {
                    for(let th=1; th<4; th++) {
                        const log = new THREE.Mesh(box, mats[4]);
                        log.position.set(x-size/2, h+th, z-size/2);
                        log.userData = { type: 4 }; scene.add(log); world.push(log);
                    }
                }
            }
        }

        // --- LUZ E DIA/NOITE ---
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(10, 20, 10); scene.add(sun);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- CONTROLES ---
        let keys = {};
        let velY = 0;
        let canJump = false;
        let selected = 1;

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code.includes('Digit')) {
                selected = parseInt(e.key);
                updateHotbar();
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        // Hotbar UI
        const hotbar = document.getElementById('hotbar');
        function updateHotbar() {
            hotbar.innerHTML = '';
            [1,2,3,4,5].forEach(i => {
                const s = document.createElement('div');
                s.className = `slot ${i === selected ? 'selected' : ''}`;
                s.style.backgroundColor = mats[i].map.image.getContext('2d').fillStyle;
                hotbar.appendChild(s);
            });
        }
        updateHotbar();

        // Quebrar/Colocar
        const ray = new THREE.Raycaster();
        window.onclick = (e) => {
            if(document.pointerLockElement !== document.body) { document.body.requestPointerLock(); return; }
            ray.setFromCamera({x:0, y:0}, camera);
            const inter = ray.intersectObjects(world);
            if(inter.length > 0) {
                if(e.button === 0) { // Esquerdo - Quebrar
                    playPopSound(200);
                    scene.remove(inter[0].object);
                    world.splice(world.indexOf(inter[0].object), 1);
                }
            }
        };

        window.oncontextmenu = (e) => {
            e.preventDefault();
            ray.setFromCamera({x:0, y:0}, camera);
            const inter = ray.intersectObjects(world);
            if(inter.length > 0) {
                playPopSound(400);
                const p = inter[0].object.position.clone().add(inter[0].face.normal);
                const m = new THREE.Mesh(box, mats[selected]);
                m.position.copy(p);
                scene.add(m); world.push(m);
            }
        };

        // --- LOOP PRINCIPAL ---
        camera.position.set(0, 15, 0);
        camera.rotation.order = 'YXZ';

        function loop() {
            requestAnimationFrame(loop);
            
            // Movimento
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            const side = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).negate();

            if(keys['KeyW']) camera.position.addScaledVector(dir, 0.15);
            if(keys['KeyS']) camera.position.addScaledVector(dir, -0.15);
            if(keys['KeyA']) camera.position.addScaledVector(side, -0.15);
            if(keys['KeyD']) camera.position.addScaledVector(side, 0.15);

            // Gravidade Simples
            velY -= 0.01;
            camera.position.y += velY;
            if(camera.position.y < 10) { camera.position.y = 10; velY = 0; canJump = true; }
            if(keys['Space'] && canJump) { velY = 0.2; canJump = false; }

            // Mouse Look
            document.onmousemove = e => {
                if(document.pointerLockElement === document.body) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            };

            renderer.render(scene, camera);
        }
        loop();
    </script>
</body>
</html>
