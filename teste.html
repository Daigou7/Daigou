<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touhou Kaguya Boss Fight (Kaguyacraft)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        canvas { border: 2px solid #6a0572; background-color: #0d0d1e; display: block; }
        #loading-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 2em;
            flex-direction: column;
            z-index: 100;
        }
        #loading-screen img { margin-top: 20px; }
    </style>
</head>
<body>
    <div id="loading-screen">
        Carregando Kaguya...
        <img src="https://i.imgur.com/eJtPITs.png" alt="Kaguya" style="width: 100px; height: auto;">
    </div>
    <canvas id="gameCanvas" width="600" height="700"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loading-screen');

        // --- Configurações do Jogo ---
        const GAME_WIDTH = canvas.width;
        const GAME_HEIGHT = canvas.height;
        const PLAYER_SPEED = 4;
        const PLAYER_BULLET_SPEED = 10;
        const PLAYER_FIRE_RATE = 8; // Frames entre cada tiro
        const ENEMY_BULLET_SPEED = 3;
        const PLAYER_HP = 3;
        const KAGUYA_HP = 100;

        // --- Variáveis de Jogo ---
        let player = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT - 50,
            width: 32, // Tamanho placeholder, ajuste para o sprite
            height: 32,
            hitboxRadius: 2, // A hitbox de Touhou é pequena!
            dx: 0,
            dy: 0,
            bullets: [],
            fireCooldown: 0,
            hp: PLAYER_HP,
            invincible: 0, // Duração da invencibilidade após tomar dano
        };

        let kaguya = {
            x: GAME_WIDTH / 2,
            y: 100,
            width: 128, // Ajuste para o sprite
            height: 128,
            hp: KAGUYA_HP,
            state: 'idle', // idle, attacking, damaged, dead
            damageTimer: 0, // Tempo que o sprite de dano fica visível
            attackTimer: 0,
            attackPattern: 0, // Qual padrão de ataque a Kaguya está usando
            patternCooldown: 180, // Tempo entre mudanças de padrões
            bullets: [],
        };

        let gamePaused = false;
        let gameOver = false;
        let gameWon = false;

        // --- Carregamento de Imagens ---
        const assets = {};
        const imagesToLoad = [
            { name: 'kaguya_idle', url: 'https://i.imgur.com/eJtPITs.png' },
            { name: 'kaguya_damaged', url: 'https://i.imgur.com/I5eFRGd.png' },
            { name: 'kaguya_dead', url: 'https://i.imgur.com/1NDnHJe.png' },
            // Adicione sprites do jogador aqui se tiver. Por enquanto, será um círculo.
            // { name: 'player_sprite', url: 'URL_DO_SPRITE_DO_JOGADOR' },
            // { name: 'player_bullet', url: 'URL_DO_SPRITE_DA_BALA_DO_JOGADOR' },
            // { name: 'enemy_bullet', url: 'URL_DO_SPRITE_DA_BALA_DO_INIMIGO' },
        ];
        let loadedImages = 0;

        function loadImage(imageName, imageUrl) {
            const img = new Image();
            img.src = imageUrl;
            img.onload = () => {
                assets[imageName] = img;
                loadedImages++;
                if (loadedImages === imagesToLoad.length) {
                    loadingScreen.style.display = 'none';
                    startGame();
                }
            };
            img.onerror = () => {
                console.error(`Falha ao carregar imagem: ${imageUrl}`);
                // Tenta iniciar mesmo com erro ou exibe mensagem
                loadedImages++;
                if (loadedImages === imagesToLoad.length) {
                    loadingScreen.style.display = 'none';
                    startGame();
                }
            };
        }

        imagesToLoad.forEach(img => loadImage(img.name, img.url));

        // --- Input Handling ---
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === 'p' || e.key === 'P') {
                gamePaused = !gamePaused;
            }
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });

        // --- Funções de Desenho ---
        function drawPlayer() {
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.width / 2, 0, Math.PI * 2);
            ctx.fillStyle = player.invincible % 10 < 5 ? 'rgba(0, 255, 255, 0.7)' : 'rgba(0, 255, 255, 0.3)'; // Pisca quando invencível
            ctx.fill();
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Desenhar hitbox
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawKaguya() {
            let kaguyaSprite;
            if (kaguya.state === 'dead' && assets.kaguya_dead) {
                kaguyaSprite = assets.kaguya_dead;
            } else if (kaguya.damageTimer > 0 && assets.kaguya_damaged) {
                kaguyaSprite = assets.kaguya_damaged;
            } else if (assets.kaguya_idle) {
                kaguyaSprite = assets.kaguya_idle;
            } else {
                // Fallback para um círculo se o sprite não carregar
                ctx.beginPath();
                ctx.arc(kaguya.x, kaguya.y, kaguya.width / 2, 0, Math.PI * 2);
                ctx.fillStyle = 'purple';
                ctx.fill();
                return;
            }

            ctx.drawImage(kaguyaSprite, kaguya.x - kaguya.width / 2, kaguya.y - kaguya.height / 2, kaguya.width, kaguya.height);

            // Desenhar barra de vida da Kaguya
            ctx.fillStyle = 'gray';
            ctx.fillRect(50, 20, GAME_WIDTH - 100, 15);
            ctx.fillStyle = 'red';
            ctx.fillRect(50, 20, (GAME_WIDTH - 100) * (kaguya.hp / KAGUYA_HP), 15);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(50, 20, GAME_WIDTH - 100, 15);
        }

        function drawPlayerBullets() {
            player.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'yellow';
                ctx.fill();
            });
        }

        function drawKaguyaBullets() {
            kaguya.bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = bullet.color;
                ctx.fill();
            });
        }

        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`HP: ${player.hp}`, 20, GAME_HEIGHT - 20);

            if (gamePaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSE', GAME_WIDTH / 2, GAME_HEIGHT / 2);
                ctx.font = '20px Arial';
                ctx.fillText('Pressione P para continuar', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
            }

            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.fillStyle = 'white';
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2);
            }

            if (gameWon) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                ctx.fillStyle = 'gold';
                ctx.font = '50px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('VITÓRIA!', GAME_WIDTH / 2, GAME_HEIGHT / 2);
                ctx.font = '30px Arial';
                ctx.fillText('Kaguya derrotada!', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50);
            }
        }

        // --- Funções de Atualização (Lógica do Jogo) ---

        function updatePlayer() {
            player.dx = 0;
            player.dy = 0;

            if (keys['ArrowLeft'] || keys['a']) player.dx = -PLAYER_SPEED;
            if (keys['ArrowRight'] || keys['d']) player.dx = PLAYER_SPEED;
            if (keys['ArrowUp'] || keys['w']) player.dy = -PLAYER_SPEED;
            if (keys['ArrowDown'] || keys['s']) player.dy = PLAYER_SPEED;

            // Foco (SHIFT) para movimento mais lento e hitbox visível
            if (keys['Shift']) {
                player.dx /= 2;
                player.dy /= 2;
            }

            player.x += player.dx;
            player.y += player.dy;

            // Limites da tela
            player.x = Math.max(player.width / 2, Math.min(GAME_WIDTH - player.width / 2, player.x));
            player.y = Math.max(GAME_HEIGHT / 2, Math.min(GAME_HEIGHT - player.height / 2, player.y)); // Manter jogador na parte de baixo

            // Atirar
            if (keys['z'] || keys['Z']) { // Z geralmente é tiro em Touhou
                if (player.fireCooldown <= 0) {
                    player.bullets.push({
                        x: player.x,
                        y: player.y - player.height / 2,
                        radius: 3,
                        speed: PLAYER_BULLET_SPEED
                    });
                    player.fireCooldown = PLAYER_FIRE_RATE;
                }
            }
            if (player.fireCooldown > 0) player.fireCooldown--;

            // Atualizar balas do jogador
            player.bullets.forEach((bullet, index) => {
                bullet.y -= bullet.speed;
                if (bullet.y < 0) {
                    player.bullets.splice(index, 1);
                }
            });

            // Invencibilidade
            if (player.invincible > 0) {
                player.invincible--;
            }
        }

        function updateKaguya() {
            if (kaguya.hp <= 0) {
                kaguya.state = 'dead';
                gameWon = true;
                return;
            }

            // Movimentação sutil da Kaguya (pode ser mais complexo depois)
            kaguya.x += Math.sin(kaguya.attackTimer * 0.05) * 0.5; // Balanço lateral
            kaguya.y += Math.cos(kaguya.attackTimer * 0.03) * 0.2; // Balanço vertical sutil

            kaguya.attackTimer++;
            if (kaguya.damageTimer > 0) {
                kaguya.damageTimer--;
            }

            // Mudar padrões de ataque
            kaguya.patternCooldown--;
            if (kaguya.patternCooldown <= 0) {
                kaguya.attackPattern = (kaguya.attackPattern + 1) % 3; // 3 padrões diferentes
                kaguya.patternCooldown = 180 + Math.random() * 120; // Próxima mudança em 3-5 segundos
                kaguya.attackTimer = 0; // Reseta timer de ataque para novo padrão
            }

            // Lógica de Ataque da Kaguya
            if (kaguya.state !== 'damaged' && kaguya.state !== 'dead') {
                if (kaguya.attackPattern === 0) { // Padrão simples: círculos em espiral
                    if (kaguya.attackTimer % 10 === 0) {
                        const numBullets = 20;
                        const angleStep = (Math.PI * 2) / numBullets;
                        for (let i = 0; i < numBullets; i++) {
                            const angle = angleStep * i + (kaguya.attackTimer * 0.05); // Espiral
                            kaguya.bullets.push({
                                x: kaguya.x,
                                y: kaguya.y,
                                radius: 5,
                                speed: ENEMY_BULLET_SPEED,
                                dx: Math.cos(angle) * ENEMY_BULLET_SPEED,
                                dy: Math.sin(angle) * ENEMY_BULLET_SPEED,
                                color: 'pink'
                            });
                        }
                    }
                } else if (kaguya.attackPattern === 1) { // Padrão de mira no jogador
                    if (kaguya.attackTimer % 30 === 0) {
                        const angleToPlayer = Math.atan2(player.y - kaguya.y, player.x - kaguya.x);
                        const spread = Math.PI / 8; // Arco de 45 graus
                        const numBullets = 5;
                        for (let i = 0; i < numBullets; i++) {
                            const currentAngle = angleToPlayer + (i - (numBullets - 1) / 2) * (spread / numBullets);
                            kaguya.bullets.push({
                                x: kaguya.x,
                                y: kaguya.y,
                                radius: 4,
                                speed: ENEMY_BULLET_SPEED * 1.2,
                                dx: Math.cos(currentAngle) * ENEMY_BULLET_SPEED * 1.2,
                                dy: Math.sin(currentAngle) * ENEMY_BULLET_SPEED * 1.2,
                                color: 'cyan'
                            });
                        }
                    }
                } else if (kaguya.attackPattern === 2) { // Padrão de "flor" / leque
                    if (kaguya.attackTimer % 60 === 0) {
                        const numRings = 3;
                        const bulletsPerRing = 10;
                        for (let r = 0; r < numRings; r++) {
                            const baseAngle = Math.random() * Math.PI * 2; // Começa em angulo aleatório
                            for (let i = 0; i < bulletsPerRing; i++) {
                                const angle = baseAngle + (Math.PI * 2 / bulletsPerRing) * i;
                                kaguya.bullets.push({
                                    x: kaguya.x,
                                    y: kaguya.y,
                                    radius: 6,
                                    speed: ENEMY_BULLET_SPEED * (0.8 + r * 0.3), // Velocidades diferentes para anéis
                                    dx: Math.cos(angle) * ENEMY_BULLET_SPEED * (0.8 + r * 0.3),
                                    dy: Math.sin(angle) * ENEMY_BULLET_SPEED * (0.8 + r *
