<!DOCTYPE html>
<html>
<head>
    <title>Eternal Waifus</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* ===== CSS RESET ===== */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        body, html { 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            touch-action: none; 
            -ms-touch-action: none;
            font-family: 'Inter', sans-serif;
        }

        /* ===== CUSTOM PROPERTIES ===== */
        :root {
            --transition-fast: 150ms;
            --transition-normal: 300ms;
            --transition-slow: 500ms;
            --ease-out: cubic-bezier(0.0, 0, 0.2, 1);
            --ease-bounce: cubic-bezier(0.68, -0.6, 0.32, 1.6);
            --space-xs: 8px;
            --space-sm: 16px;
            --space-md: 24px;
            --space-lg: 32px;
            --space-xl: 48px;
            --color-primary: #00FFFF;
            --color-danger: #FF4444;
            --color-success: #00FF88;
            --color-bg-dark: rgba(0, 0, 20, 0.95);
            --color-bg-overlay: rgba(0, 0, 0, 0.8);
        }

        /* ===== GAME CONTAINER ===== */
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        /* ===== HUD OVERLAY ===== */
        .hud-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-top {
            position: absolute;
            top: var(--space-sm);
            left: var(--space-sm);
            right: var(--space-sm);
            display: flex;
            flex-direction: row;
            gap: var(--space-md);
            align-items: center;
        }

        .health-bar-container {
            background: var(--color-bg-dark);
            border: 2px solid var(--color-primary);
            border-radius: 8px;
            padding: var(--space-xs);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
            flex: 1;
            min-width: 300px;
        }

        .health-bar {
            width: 100%;
            height: 24px;
            background: rgba(255, 68, 68, 0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FF8844);
            transition: width var(--transition-normal) var(--ease-out);
            box-shadow: 0 0 12px rgba(255, 68, 68, 0.6);
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        .wave-info {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: var(--color-bg-dark);
            border: 2px solid var(--color-primary);
            border-radius: 8px;
            padding: var(--space-xs) var(--space-md);
            box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
            min-width: 300px;
        }

        .wave-text, .score-text {
            color: var(--color-primary);
            font-size: 28px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
        }

        /* ===== VIRTUAL JOYSTICK ===== */
        .joystick-container {
            position: absolute;
            bottom: var(--space-lg);
            left: var(--space-lg);
            width: 160px;
            height: 160px;
            pointer-events: auto;
            z-index: 20;
            display: none; /* Hidden by default, shown on touch devices */
        }

        .joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.05));
            border: 3px solid rgba(0, 255, 255, 0.4);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .joystick-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.8), rgba(0, 255, 255, 0.4));
            border: 3px solid var(--color-primary);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transition: transform var(--transition-fast) var(--ease-out);
        }

        /* ===== CARD SELECTION MODAL ===== */
        .card-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--color-bg-overlay);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }

        .card-modal.active {
            display: flex;
        }

        .card-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            padding: var(--space-lg);
            max-width: 90%;
        }

        .card-title {
            color: var(--color-primary);
            font-size: 40px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            text-shadow: 0 0 16px rgba(0, 255, 255, 0.8);
            margin-bottom: var(--space-sm);
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-sm);
            width: 100%;
            max-width: 680px;
        }

        .spell-card {
            background: linear-gradient(135deg, rgba(0, 100, 200, 0.3), rgba(100, 0, 200, 0.3));
            border: 3px solid var(--color-primary);
            border-radius: 12px;
            padding: var(--space-md);
            cursor: pointer;
            transition: all var(--transition-normal) var(--ease-out);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-sm);
            min-height: 240px;
        }

        .spell-card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.6);
        }

        .spell-card:active {
            transform: translateY(-2px) scale(1.0);
            box-shadow: 0 4px 16px rgba(0, 255, 136, 0.8);
        }

        @media (hover: none) {
            .spell-card:hover {
                transform: none;
                box-shadow: none;
            }
        }

        .card-icon {
            width: 96px;
            height: 96px;
            object-fit: contain;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.6));
        }

        .card-name {
            color: white;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
        }

        .card-description {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            text-align: center;
            line-height: 1.4;
        }

        /* ===== DEATH SCREEN ===== */
        .death-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--color-bg-overlay);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-lg);
            z-index: 100;
            pointer-events: auto;
        }

        .death-screen.active {
            display: flex;
        }

        .death-title {
            color: var(--color-danger);
            font-size: 60px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 24px rgba(255, 68, 68, 0.8);
            animation: pulse 2s ease-in-out infinite;
        }

        .death-stats {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            background: var(--color-bg-dark);
            border: 3px solid var(--color-primary);
            border-radius: 12px;
            padding: var(--space-lg);
        }

        .death-stat {
            color: white;
            font-size: 28px;
            text-align: center;
            font-family: 'Inter', sans-serif;
        }

        .death-stat span {
            color: var(--color-primary);
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
        }

        .restart-button {
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border: 2px solid #00FFFF;
            border-radius: 8px;
            padding: var(--space-md) var(--space-xl);
            color: #00FFFF;
            font-size: 32px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all var(--transition-normal) var(--ease-out);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
            min-width: 200px;
            min-height: 96px;
        }

        .restart-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), inset 0 0 20px rgba(0, 255, 255, 0.2);
            background: linear-gradient(135deg, #262626, #1a1a1a);
        }

        .restart-button:active {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.15);
        }

        /* ===== ANIMATIONS ===== */
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        /* ===== REDUCED MOTION ===== */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            
            .joystick-knob {
                transition: none;
            }
        }

        /* ===== MAIN MENU ===== */
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 20, 50, 0.95), rgba(20, 0, 50, 0.95));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-lg);
            z-index: 200;
            pointer-events: auto;
        }

        .main-menu.hidden {
            display: none;
        }

        .menu-logo {
            max-width: 300px;
            height: auto;
            margin-bottom: var(--space-lg);
            filter: drop-shadow(0 0 16px rgba(0, 255, 255, 0.6));
        }

        .menu-subtitle {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            text-align: center;
            margin-bottom: var(--space-lg);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            align-items: center;
        }

        .start-button, .settings-button {
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border: 2px solid #00FFFF;
            border-radius: 8px;
            padding: var(--space-md) var(--space-xl);
            color: #00FFFF;
            font-size: 32px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all var(--transition-normal) var(--ease-out);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
            min-width: 240px;
            min-height: 80px;
        }

        .settings-button {
            font-size: 24px;
            min-width: 200px;
            min-height: 60px;
        }

        .start-button:hover, .settings-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), inset 0 0 20px rgba(0, 255, 255, 0.2);
            background: linear-gradient(135deg, #262626, #1a1a1a);
        }

        .start-button:active, .settings-button:active {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.15);
        }

        /* ===== SETTINGS MENU ===== */
        .settings-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 20, 50, 0.95), rgba(20, 0, 50, 0.95));
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 200;
            pointer-events: auto;
            overflow-y: auto;
            padding: var(--space-lg);
        }

        .settings-menu.active {
            display: flex;
        }

        .settings-title {
            color: var(--color-primary);
            font-size: 48px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 24px rgba(0, 255, 255, 0.8);
            text-align: center;
            margin-bottom: var(--space-lg);
            margin-top: var(--space-lg);
        }

        .settings-content {
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            width: 100%;
            max-width: 600px;
        }

        .setting-item {
            background: var(--color-bg-dark);
            border: 2px solid var(--color-primary);
            border-radius: 12px;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        .setting-label {
            color: var(--color-primary);
            font-size: 18px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
        }

        .setting-value {
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            text-align: right;
        }

        .setting-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(0, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00FF88, #00FFFF);
            cursor: pointer;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
        }

        .setting-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00FF88, #00FFFF);
            cursor: pointer;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
            border: none;
        }

        .settings-back-button {
            background: linear-gradient(135deg, #1a1a1a, #0d0d0d);
            border: 2px solid #FF4444;
            border-radius: 8px;
            padding: var(--space-md) var(--space-xl);
            color: #FF4444;
            font-size: 24px;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all var(--transition-normal) var(--ease-out);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3), inset 0 0 20px rgba(255, 68, 68, 0.1);
            min-width: 200px;
            min-height: 60px;
            margin-top: var(--space-lg);
            margin-bottom: var(--space-lg);
        }

        .settings-back-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.6), inset 0 0 20px rgba(255, 68, 68, 0.2);
            background: linear-gradient(135deg, #262626, #1a1a1a);
        }

        .settings-back-button:active {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4), inset 0 0 20px rgba(255, 68, 68, 0.15);
        }

        /* ===== MOBILE DETECTION ===== */
        @media (hover: none) and (pointer: coarse) {
            .joystick-container {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- Main Menu -->
        <div class="main-menu" id="main-menu">
            <img id="menu-logo-img" class="menu-logo" src="" alt="Game Logo">
            <div class="menu-subtitle">created and developed by Daigou</div>
            
            <div class="menu-buttons">
                <button class="start-button" id="start-button">START GAME</button>
                <button class="settings-button" id="settings-button">SETTINGS</button>
            </div>
        </div>

        <div class="settings-menu" id="settings-menu">
            <div class="settings-title">SETTINGS</div>
            
            <div class="settings-content">
                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Player Health</div>
                        <div class="setting-value" id="health-value">200</div>
                    </div>
                    <input type="range" class="setting-slider" id="health-slider" min="50" max="200" step="10" value="200">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Player Speed</div>
                        <div class="setting-value" id="speed-value">300</div>
                    </div>
                    <input type="range" class="setting-slider" id="speed-slider" min="100" max="300" step="10" value="300">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Attack Speed</div>
                        <div class="setting-value" id="attack-speed-value">5</div>
                    </div>
                    <input type="range" class="setting-slider" id="attack-speed-slider" min="1" max="5" step="0.25" value="5">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Base Damage</div>
                        <div class="setting-value" id="damage-value">20</div>
                    </div>
                    <input type="range" class="setting-slider" id="damage-slider" min="5" max="20" step="1" value="20">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Wave Count</div>
                        <div class="setting-value" id="wave-count-value">3</div>
                    </div>
                    <input type="range" class="setting-slider" id="wave-count-slider" min="3" max="20" step="1" value="3">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Wave Duration</div>
                        <div class="setting-value" id="wave-duration-value">20</div>
                    </div>
                    <input type="range" class="setting-slider" id="wave-duration-slider" min="20" max="60" step="5" value="20">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Spawn Rate</div>
                        <div class="setting-value" id="spawn-rate-value">0.5</div>
                    </div>
                    <input type="range" class="setting-slider" id="spawn-rate-slider" min="0.5" max="3" step="0.1" value="0.5">
                </div>

                <div class="setting-item">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div class="setting-label">Difficulty Scaling</div>
                        <div class="setting-value" id="difficulty-value">0.1</div>
                    </div>
                    <input type="range" class="setting-slider" id="difficulty-slider" min="0.1" max="0.5" step="0.05" value="0.1">
                </div>
            </div>

            <button class="settings-back-button" id="settings-back-button">BACK</button>
        </div>
        
        <!-- HUD Overlay -->
        <div class="hud-overlay">
            <div class="hud-top">
                <div class="health-bar-container">
                    <div class="health-bar">
                        <div class="health-bar-fill" id="health-fill"></div>
                        <div class="health-text" id="health-text">100 / 100</div>
                    </div>
                </div>
                <div class="wave-info">
                    <div class="wave-text" id="wave-text">Wave 1</div>
                    <div class="score-text" id="score-text">Score: 0</div>
                </div>
            </div>
        </div>

        <!-- Virtual Joystick -->
        <div class="joystick-container" id="joystick-container">
            <div class="joystick-base"></div>
            <div class="joystick-knob" id="joystick-knob"></div>
        </div>

        <!-- Card Selection Modal -->
        <div class="card-modal" id="card-modal">
            <div class="card-container">
                <div class="card-title">Choose Your Power!</div>
                <div class="card-grid" id="card-grid"></div>
            </div>
        </div>

        <!-- Death Screen -->
        <div class="death-screen" id="death-screen">
            <div class="death-title">GAME OVER</div>
            <div class="death-stats">
                <div class="death-stat">Waves Survived: <span id="final-wave">0</span></div>
                <div class="death-stat">Enemies Defeated: <span id="final-kills">0</span></div>
                <div class="death-stat">Final Score: <span id="final-score">0</span></div>
            </div>
            <button class="restart-button" id="restart-button">RESTART</button>
        </div>
    </div>

    <script>
        /* ==================================================
         * GAME OVERVIEW: Anime Energy Rogue
         * 
         * Top-down roguelike shooter where the player auto-shoots energy balls
         * at enemies while dodging incoming threats. Survive waves of enemies,
         * defeat bosses, and choose spell cards to upgrade your abilities.
         * 
         * GAME STATE SHAPE: window.gameConfig = {
         *   player: { startHealth, moveSpeed, attackSpeed, damage, color },
         *   waves: { count, duration, spawnRateMultiplier, difficultyScaling },
         *   enemies: {
         *     small: { health, speed, color },
         *     medium: { health, speed, color },
         *     large: { health, speed, color },
         *     boss: { healthMultiplier, speed, color }
         *   },
         *   spellCards: {
         *     available: { [cardName]: boolean },
         *     cardsPerWave: number
         *   }
         * }
         * ==================================================
         */

        // ===== GLOBAL STATE =====
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const ARENA_WIDTH = 720;
        const ARENA_HEIGHT = 1280;
        
        let audioContext;
        let assetCache = {};
        let audioBuffers = {};
        let currentMode = 'play';
        
        let gameState = {
            phase: 'playing', // 'playing' | 'card-selection' | 'game-over'
            player: {
                x: ARENA_WIDTH / 2,
                y: ARENA_HEIGHT / 2,
                vx: 0,
                vy: 0,
                health: 100,
                maxHealth: 100,
                rotation: 0,
                size: 32
            },
            enemies: [],
            projectiles: [],
            effects: [], // Visual effects like explosions
            wave: 1,
            waveTimer: 0,
            waveDuration: 30,
            bossSpawned: false,
            score: 0,
            kills: 0,
            lifeStealKills: 0,
            shootTimer: 0,
            activeEffects: {
                fireball: false,
                ice: false,
                lightning: false,
                tornado: { active: false, timer: 0, x: 0, y: 0, lifetime: 0 },
                shield: { active: false, timer: 0 }
            },
            stats: {
                damage: 10,
                attackSpeed: 2,
                moveSpeed: 200,
                projectileCount: 1,
                damageMultiplier: 1,
                speedMultiplier: 1
            },
            input: {
                keys: {},
                joystick: { active: false, x: 0, y: 0 }
            }
        };

        let lastTime = 0;
        let animationId = null;

        // ===== SPELL CARD DEFINITIONS =====
        const SPELL_CARDS = {
            // COMMON CARDS
            catalyst: {
                name: 'Catalyst',
                description: 'Projectile damage +2',
                rarity: 'common',
                icon: 'card_fireball',
                apply: () => { gameState.stats.damage += 2; }
            },
            eyesight: {
                name: 'Eyesight',
                description: 'Critical chance +5%',
                rarity: 'common',
                icon: 'card_projectile',
                apply: () => { gameState.stats.critChance = (gameState.stats.critChance || 0) + 0.05; }
            },
            growth: {
                name: 'Growth',
                description: 'Max HP +10',
                rarity: 'common',
                icon: 'card_health',
                apply: () => {
                    gameState.player.maxHealth += 10;
                    gameState.player.health = Math.min(gameState.player.health + 10, gameState.player.maxHealth);
                    updateHealthUI();
                }
            },
            impulse: {
                name: 'Impulse',
                description: 'Jump height +30%',
                rarity: 'common',
                icon: 'card_projectile',
                apply: () => { gameState.stats.jumpHeight = (gameState.stats.jumpHeight || 1) * 1.3; }
            },
            renew: {
                name: 'Renew',
                description: 'Heal to max HP',
                rarity: 'common',
                icon: 'card_health',
                apply: () => {
                    gameState.player.health = gameState.player.maxHealth;
                    updateHealthUI();
                }
            },
            resist: {
                name: 'Resist',
                description: 'Defense +4%',
                rarity: 'common',
                icon: 'card_shield',
                apply: () => { gameState.stats.defense = (gameState.stats.defense || 0) + 0.04; }
            },
            resonance: {
                name: 'Resonance',
                description: 'Attack speed +12%',
                rarity: 'common',
                icon: 'card_speed',
                apply: () => { gameState.stats.attackSpeed *= 1.12; }
            },
            souls: {
                name: 'Souls',
                description: '1% chance for soul orb drop',
                rarity: 'common',
                icon: 'card_projectile',
                apply: () => { gameState.stats.soulDropChance = (gameState.stats.soulDropChance || 0) + 0.01; }
            },
            stability: {
                name: 'Stability',
                description: 'Projectiles hit +1 extra time',
                rarity: 'common',
                icon: 'card_projectile',
                apply: () => { gameState.stats.projectileHits = (gameState.stats.projectileHits || 1) + 1; }
            },
            swift: {
                name: 'Swift',
                description: 'Movement speed +20%',
                rarity: 'common',
                icon: 'card_movement',
                apply: () => { gameState.stats.speedMultiplier *= 1.2; }
            },

            // UNCOMMON CARDS
            catalystPlus: {
                name: 'Catalyst+',
                description: 'Projectile damage +4',
                rarity: 'uncommon',
                icon: 'card_fireball',
                apply: () => { gameState.stats.damage += 4; }
            },
            charge: {
                name: 'Charge',
                description: 'Projectile size +20%',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.stats.projectileSize = (gameState.stats.projectileSize || 1) * 1.2; }
            },
            cloak: {
                name: 'Cloak',
                description: 'Increased invulnerability after damage',
                rarity: 'uncommon',
                icon: 'card_shield',
                apply: () => { gameState.stats.invulnDuration = (gameState.stats.invulnDuration || 0.5) + 0.3; }
            },
            fragmentation: {
                name: 'Fragmentation',
                description: 'Enemies release 2 projectiles on death',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.stats.fragmentationCount = (gameState.stats.fragmentationCount || 0) + 2; }
            },
            friction: {
                name: 'Friction',
                description: 'Launch 1 explosive per meter moved',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.stats.frictionProjectiles = (gameState.stats.frictionProjectiles || 0) + 1; }
            },
            growthPlus: {
                name: 'Growth+',
                description: 'Max HP +20',
                rarity: 'uncommon',
                icon: 'card_health',
                apply: () => {
                    gameState.player.maxHealth += 20;
                    gameState.player.health = Math.min(gameState.player.health + 20, gameState.player.maxHealth);
                    updateHealthUI();
                }
            },
            gush: {
                name: 'Gush',
                description: '+1 jump',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.stats.jumps = (gameState.stats.jumps || 1) + 1; }
            },
            leech: {
                name: 'Leech',
                description: '3% life steal from damage',
                rarity: 'uncommon',
                icon: 'card_lifesteal',
                apply: () => { gameState.stats.lifesteal = (gameState.stats.lifesteal || 0) + 0.03; }
            },
            luck: {
                name: 'Luck',
                description: 'Higher chance for uncommon items',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.stats.luckMultiplier = (gameState.stats.luckMultiplier || 1) * 1.5; }
            },
            orb: {
                name: 'Orb',
                description: '5% chance for healing orbs',
                rarity: 'uncommon',
                icon: 'card_health',
                apply: () => { gameState.stats.orbDropChance = (gameState.stats.orbDropChance || 0) + 0.05; }
            },
            precision: {
                name: 'Precision',
                description: 'Critical hits deal +50% damage',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.stats.critDamage = (gameState.stats.critDamage || 1) + 0.5; }
            },
            rage: {
                name: 'Rage',
                description: 'Up to +50% damage below 50% HP',
                rarity: 'uncommon',
                icon: 'card_fireball',
                apply: () => { gameState.stats.rageEnabled = true; }
            },
            regrowth: {
                name: 'Regrowth',
                description: 'Regenerate HP based on enemies alive',
                rarity: 'uncommon',
                icon: 'card_health',
                apply: () => { gameState.stats.regrowthEnabled = true; }
            },
            resonancePlus: {
                name: 'Resonance+',
                description: 'Attack speed +24%',
                rarity: 'uncommon',
                icon: 'card_speed',
                apply: () => { gameState.stats.attackSpeed *= 1.24; }
            },
            shrink: {
                name: 'Shrink',
                description: 'Hitbox size reduced by 10%',
                rarity: 'uncommon',
                icon: 'card_projectile',
                apply: () => { gameState.player.size *= 0.9; }
            },
            swiftPlus: {
                name: 'Swift+',
                description: 'Movement speed +40%',
                rarity: 'uncommon',
                icon: 'card_movement',
                apply: () => { gameState.stats.speedMultiplier *= 1.4; }
            },
            thunderbolt: {
                name: 'Thunderbolt',
                description: 'Periodically calls 2 lightning strikes',
                rarity: 'uncommon',
                icon: 'card_lightning',
                apply: () => { gameState.stats.thunderboltCount = (gameState.stats.thunderboltCount || 0) + 2; }
            },

            // EPIC CARDS
            appraisal: {
                name: 'Appraisal',
                description: '+1 extra choice on every card pick',
                rarity: 'epic',
                icon: 'card_projectile',
                apply: () => { window.gameConfig.spellCards.cardsPerWave += 1; }
            },
            barrier: {
                name: 'Barrier',
                description: 'Periodic shield that blocks damage',
                rarity: 'epic',
                icon: 'card_shield',
                apply: () => { gameState.stats.barrierEnabled = true; gameState.stats.barrierCharges = (gameState.stats.barrierCharges || 0) + 1; }
            },
            cold: {
                name: 'Cold',
                description: 'Damaging enemies slows them (up to 80%)',
                rarity: 'epic',
                icon: 'card_ice',
                apply: () => { gameState.stats.coldEnabled = true; }
            },
            fragmentationPlus: {
                name: 'Fragmentation+',
                description: 'Enemies release 6 projectiles on death',
                rarity: 'epic',
                icon: 'card_projectile',
                apply: () => { gameState.stats.fragmentationCount = (gameState.stats.fragmentationCount || 0) + 6; }
            },
            frictionPlus: {
                name: 'Friction+',
                description: 'Launch 3 explosive projectiles per meter',
                rarity: 'epic',
                icon: 'card_projectile',
                apply: () => { gameState.stats.frictionProjectiles = (gameState.stats.frictionProjectiles || 0) + 3; }
            },
            focus: {
                name: 'Focus',
                description: 'Gain attack speed while standing still',
                rarity: 'epic',
                icon: 'card_speed',
                apply: () => { gameState.stats.focusEnabled = true; }
            },
            growthPlusPlus: {
                name: 'Growth++',
                description: 'Max HP +40',
                rarity: 'epic',
                icon: 'card_health',
                apply: () => {
                    gameState.player.maxHealth += 40;
                    gameState.player.health = Math.min(gameState.player.health + 40, gameState.player.maxHealth);
                    updateHealthUI();
                }
            },
            leechPlus: {
                name: 'Leech+',
                description: '9% life steal from damage',
                rarity: 'epic',
                icon: 'card_lifesteal',
                apply: () => { gameState.stats.lifesteal = (gameState.stats.lifesteal || 0) + 0.09; }
            },
            overheat: {
                name: 'Overheat',
                description: 'Body contact deals 40 damage',
                rarity: 'epic',
                icon: 'card_fireball',
                apply: () => { gameState.stats.bodyDamage = (gameState.stats.bodyDamage || 0) + 40; }
            },
            thunderboltPlus: {
                name: 'Thunderbolt+',
                description: 'Periodically calls 6 lightning strikes',
                rarity: 'epic',
                icon: 'card_lightning',
                apply: () => { gameState.stats.thunderboltCount = (gameState.stats.thunderboltCount || 0) + 6; }
            },
            tome: {
                name: 'Tome',
                description: 'Common cards 35% more effective',
                rarity: 'epic',
                icon: 'card_projectile',
                apply: () => { gameState.stats.tomeMultiplier = (gameState.stats.tomeMultiplier || 1) * 1.35; }
            },
            willOWisp: {
                name: 'Will-O-Wisp',
                description: 'Summons a wisp that attacks with half stats',
                rarity: 'epic',
                icon: 'card_projectile',
                apply: () => { gameState.stats.wispCount = (gameState.stats.wispCount || 0) + 1; }
            },
            wound: {
                name: 'Wound',
                description: 'Damage applies bleeding',
                rarity: 'epic',
                icon: 'card_fireball',
                apply: () => { gameState.stats.woundEnabled = true; }
            },

            // LEGENDARY CARDS
            absorbent: {
                name: 'Absorbent',
                description: 'Invulnerable hits heal and grant Cloak',
                rarity: 'legendary',
                icon: 'card_shield',
                apply: () => { gameState.stats.absorbentEnabled = true; }
            },
            antiAircraft: {
                name: 'Anti-Aircraft',
                description: 'Friction explosions larger and stronger',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.antiAircraftEnabled = true; }
            },
            avenger: {
                name: 'Avenger',
                description: 'Prevent death, kill half enemies, heal 50%',
                rarity: 'legendary',
                icon: 'card_shield',
                apply: () => { gameState.stats.avengerEnabled = true; gameState.stats.avengerCooldown = 0; }
            },
            blessed: {
                name: 'Blessed',
                description: '+5% epic item chance per roll',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.epicChanceBonus = (gameState.stats.epicChanceBonus || 0) + 0.05; }
            },
            bloodyMage: {
                name: 'Bloody Mage',
                description: 'Bleeding deals damage faster',
                rarity: 'legendary',
                icon: 'card_fireball',
                apply: () => { gameState.stats.bleedingSpeedMultiplier = (gameState.stats.bleedingSpeedMultiplier || 1) * 2; }
            },
            bulldozer: {
                name: 'Bulldozer',
                description: 'Easier enemy pushback and movement boost',
                rarity: 'legendary',
                icon: 'card_movement',
                apply: () => { gameState.stats.pushbackMultiplier = (gameState.stats.pushbackMultiplier || 1) * 1.5; gameState.stats.speedMultiplier *= 1.15; }
            },
            bunker: {
                name: 'Bunker',
                description: 'Gain armor while standing still',
                rarity: 'legendary',
                icon: 'card_shield',
                apply: () => { gameState.stats.bunkerEnabled = true; }
            },
            burningMan: {
                name: 'Burning Man',
                description: 'Periodic body-damage aura',
                rarity: 'legendary',
                icon: 'card_fireball',
                apply: () => { gameState.stats.burningAuraEnabled = true; }
            },
            colossus: {
                name: 'Colossus',
                description: 'Double max HP and size',
                rarity: 'legendary',
                icon: 'card_health',
                apply: () => {
                    gameState.player.maxHealth *= 2;
                    gameState.player.health = gameState.player.maxHealth;
                    gameState.player.size *= 2;
                    updateHealthUI();
                }
            },
            comet: {
                name: 'Comet',
                description: 'Landing from jumps deals AoE damage',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.cometEnabled = true; }
            },
            dealer: {
                name: 'Dealer',
                description: 'Free rerolls',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.freeRerolls = (gameState.stats.freeRerolls || 0) + 1; }
            },
            desperate: {
                name: 'Desperate',
                description: 'Heal to full HP at wave start',
                rarity: 'legendary',
                icon: 'card_health',
                apply: () => { gameState.stats.desperateEnabled = true; }
            },
            enchanter: {
                name: 'Enchanter',
                description: 'Wisps shoot forward from staff tip',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.enchanterEnabled = true; }
            },
            exorcist: {
                name: 'Exorcist',
                description: 'Soul pickups release damaging beams',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.exorcistEnabled = true; }
            },
            freezer: {
                name: 'Freezer',
                description: 'Slows up to 100% and can instantly kill',
                rarity: 'legendary',
                icon: 'card_ice',
                apply: () => { gameState.stats.freezerEnabled = true; }
            },
            flyingSorcerer: {
                name: 'Flying Sorcerer',
                description: 'Unlimited jumps',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.unlimitedJumps = true; }
            },
            gnome: {
                name: 'Gnome',
                description: 'Enemy projectiles 33% chance to miss',
                rarity: 'legendary',
                icon: 'card_shield',
                apply: () => { gameState.stats.gnomeEnabled = true; }
            },
            godOfThunder: {
                name: 'God of Thunder',
                description: 'Thunderbolts deal triple damage',
                rarity: 'legendary',
                icon: 'card_lightning',
                apply: () => { gameState.stats.thunderboltDamageMultiplier = (gameState.stats.thunderboltDamageMultiplier || 1) * 3; }
            },
            hoarder: {
                name: 'Hoarder',
                description: 'Healing orbs charge your next attack',
                rarity: 'legendary',
                icon: 'card_health',
                apply: () => { gameState.stats.hoarderEnabled = true; }
            },
            marksman: {
                name: 'Marksman',
                description: 'First hit is always a critical',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.marksmanEnabled = true; gameState.stats.marksmanFirstHit = true; }
            },
            nerd: {
                name: 'Nerd',
                description: 'Gain a random common card every wave',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.nerdEnabled = true; }
            },
            pacMan: {
                name: 'Pac-Man',
                description: 'Projectiles gain damage passing through',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.pacManEnabled = true; }
            },
            plagueSpread: {
                name: 'Plague Spreader',
                description: 'Enemies lose 1% HP per second',
                rarity: 'legendary',
                icon: 'card_fireball',
                apply: () => { gameState.stats.plagueEnabled = true; }
            },
            protector: {
                name: 'Protector',
                description: 'Shield break fires projectiles',
                rarity: 'legendary',
                icon: 'card_shield',
                apply: () => { gameState.stats.protectorEnabled = true; }
            },
            ramDestroyer: {
                name: 'RAM Destroyer',
                description: 'Fragmentation projectiles decay slower',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.ramDestroyerEnabled = true; }
            },
            sadistic: {
                name: 'Sadistic',
                description: 'Reflect damage when hit',
                rarity: 'legendary',
                icon: 'card_fireball',
                apply: () => { gameState.stats.sadisticEnabled = true; }
            },
            speculator: {
                name: 'Speculator',
                description: 'Enables super critical hits',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.speculatorEnabled = true; }
            },
            streamer: {
                name: 'Streamer',
                description: 'Beam attack scales with attack speed',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.streamerEnabled = true; }
            },
            tryhard: {
                name: 'Tryhard',
                description: 'Does nothing (joke card)',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { /* Does nothing */ }
            },
            vampire: {
                name: 'Vampire',
                description: '50% of all damage heals you',
                rarity: 'legendary',
                icon: 'card_lifesteal',
                apply: () => { gameState.stats.vampireEnabled = true; }
            },
            whiteDwarf: {
                name: 'White Dwarf',
                description: 'Projectiles create black holes on impact',
                rarity: 'legendary',
                icon: 'card_projectile',
                apply: () => { gameState.stats.whiteDwarfEnabled = true; }
            }
        };

        // Rarity colors for UI
        const RARITY_COLORS = {
            common: '#FFFFFF',
            uncommon: '#00FF88',
            epic: '#FF00FF',
            legendary: '#FFD700'
        };

        // ===== ASSET LOADING =====
        async function preloadAssets() {
            lib.log('Preloading assets...');
            
            // Initialize audio context
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const assetIds = [
                'game_logo', 'player_character', 'enemy_small', 'enemy_medium', 'enemy_large', 'enemy_boss',
                'castle_background', 'card_fireball', 'card_ice', 'card_lightning', 'card_health',
                'card_speed', 'card_tornado', 'card_shield', 'card_projectile', 'card_movement',
                'card_lifesteal', 'hit_sound', 'shoot_sound', 'enemy_death_sound', 'boss_death_sound',
                'player_hurt_sound', 'card_select_sound', 'wave_complete_sound', 'tornado_sound',
                'background_music'
            ];

            const loadPromises = assetIds.map(id => {
                const assetInfo = lib.getAsset(id);
                if (!assetInfo) {
                    lib.log(`Asset ${id} not found`);
                    return Promise.resolve();
                }

                if (assetInfo.type === 'audio') {
                    return fetch(assetInfo.url)
                        .then(response => response.arrayBuffer())
                        .then(buffer => audioContext.decodeAudioData(buffer))
                        .then(audioBuffer => {
                            audioBuffers[id] = audioBuffer;
                            lib.log(`Loaded audio: ${id}`);
                        })
                        .catch(err => lib.log(`Error loading audio ${id}: ${err}`));
                } else {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            assetCache[id] = img;
                            lib.log(`Loaded image: ${id}`);
                            resolve();
                        };
                        img.onerror = () => {
                            lib.log(`Error loading image: ${id}`);
                            resolve();
                        };
                        img.src = assetInfo.url;
                    });
                }
            });

            await Promise.all(loadPromises);
            lib.log('All assets loaded');
            
            // Set logo image
            const logoImg = document.getElementById('menu-logo-img');
            if (assetCache['game_logo']) {
                logoImg.src = assetCache['game_logo'].src;
            }
        }

        // ===== MAIN MENU SETUP =====
        function setupMainMenu() {
            const startBtn = document.getElementById('start-button');
            const settingsBtn = document.getElementById('settings-button');
            const settingsBackBtn = document.getElementById('settings-back-button');
            const mainMenu = document.getElementById('main-menu');
            const settingsMenu = document.getElementById('settings-menu');
            
            // Start button
            startBtn.addEventListener('click', () => {
                mainMenu.classList.add('hidden');
                settingsMenu.classList.remove('active');
                initGame();
                playSound('background_music', true);
                lastTime = performance.now();
                gameLoop(lastTime);
            });
            
            // Settings button
            settingsBtn.addEventListener('click', () => {
                mainMenu.classList.add('hidden');
                settingsMenu.classList.add('active');
            });
            
            // Settings back button
            settingsBackBtn.addEventListener('click', () => {
                settingsMenu.classList.remove('active');
                mainMenu.classList.remove('hidden');
            });
            
            // Setup settings sliders
            setupSettingsSliders();
        }

        function setupSettingsSliders() {
            const sliders = [
                { id: 'health-slider', valueId: 'health-value', configKey: 'player.startHealth', format: (v) => Math.round(v) },
                { id: 'speed-slider', valueId: 'speed-value', configKey: 'player.moveSpeed', format: (v) => Math.round(v) },
                { id: 'attack-speed-slider', valueId: 'attack-speed-value', configKey: 'player.attackSpeed', format: (v) => v.toFixed(2) },
                { id: 'damage-slider', valueId: 'damage-value', configKey: 'player.damage', format: (v) => Math.round(v) },
                { id: 'wave-count-slider', valueId: 'wave-count-value', configKey: 'waves.count', format: (v) => Math.round(v) },
                { id: 'wave-duration-slider', valueId: 'wave-duration-value', configKey: 'waves.duration', format: (v) => Math.round(v) },
                { id: 'spawn-rate-slider', valueId: 'spawn-rate-value', configKey: 'waves.spawnRateMultiplier', format: (v) => v.toFixed(1) },
                { id: 'difficulty-slider', valueId: 'difficulty-value', configKey: 'waves.difficultyScaling', format: (v) => v.toFixed(2) }
            ];
            
            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                // Set initial value from config
                const keys = slider.configKey.split('.');
                let value = window.gameConfig;
                for (const key of keys) {
                    value = value[key];
                }
                element.value = value;
                valueElement.textContent = slider.format(value);
                
                // Update on change
                element.addEventListener('input', (e) => {
                    const newValue = parseFloat(e.target.value);
                    valueElement.textContent = slider.format(newValue);
                    
                    // Update config
                    const keys = slider.configKey.split('.');
                    let obj = window.gameConfig;
                    for (let i = 0; i < keys.length - 1; i++) {
                        obj = obj[keys[i]];
                    }
                    obj[keys[keys.length - 1]] = newValue;
                });
            });
        }

        // ===== AUDIO SYSTEM =====
        function playSound(soundId, loop = false) {
            if (!audioBuffers[soundId]) return;
            
            try {
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffers[soundId];
                source.loop = loop;
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = soundId === 'background_music' ? 0.3 : 0.5;
                
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
                
                return source;
            } catch (err) {
                lib.log(`Error playing sound ${soundId}: ${err}`);
            }
        }

        // ===== INPUT HANDLING =====
        function setupInput() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd', ' '].includes(e.key)) {
                    e.preventDefault();
                }
                gameState.input.keys[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
                gameState.input.keys[e.key.toLowerCase()] = false;
            });

            // Touch joystick
            const joystickContainer = document.getElementById('joystick-container');
            const joystickKnob = document.getElementById('joystick-knob');
            let touchId = null;

            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (touchId !== null) return;
                
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                gameState.input.joystick.active = true;
                updateJoystick(touch.clientX, touch.clientY);
            });

            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
                if (touch) {
                    updateJoystick(touch.clientX, touch.clientY);
                }
            });

            joystickContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                const touch = Array.from(e.changedTouches).find(t => t.identifier === touchId);
                if (touch) {
                    touchId = null;
                    gameState.input.joystick.active = false;
                    gameState.input.joystick.x = 0;
                    gameState.input.joystick.y = 0;
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }
            });

            function updateJoystick(clientX, clientY) {
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = clientX - centerX;
                let dy = clientY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxRadius = 60;
                
                if (distance > maxRadius) {
                    dx = (dx / distance) * maxRadius;
                    dy = (dy / distance) * maxRadius;
                }
                
                gameState.input.joystick.x = dx / maxRadius;
                gameState.input.joystick.y = dy / maxRadius;
                
                joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }

            // Restart button
            document.getElementById('restart-button').addEventListener('click', () => {
                restartGame();
            });

            // Clear input on blur
            window.addEventListener('blur', () => {
                gameState.input.keys = {};
                gameState.input.joystick.active = false;
                gameState.input.joystick.x = 0;
                gameState.input.joystick.y = 0;
            });
        }

        // ===== GAME INITIALIZATION =====
        function initGame() {
            // Reset game state from config
            const config = window.gameConfig;
            
            gameState.player.health = config.player.startHealth;
            gameState.player.maxHealth = config.player.startHealth;
            gameState.player.x = ARENA_WIDTH / 2;
            gameState.player.y = ARENA_HEIGHT / 2;
            gameState.player.vx = 0;
            gameState.player.vy = 0;
            gameState.player.rotation = 0;
            
            gameState.stats.damage = config.player.damage;
            gameState.stats.attackSpeed = config.player.attackSpeed;
            gameState.stats.moveSpeed = config.player.moveSpeed;
            gameState.stats.projectileCount = 1;
            gameState.stats.damageMultiplier = 1;
            gameState.stats.speedMultiplier = 1;
            
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.effects = [];
            gameState.wave = 1;
            gameState.waveTimer = 0;
            gameState.waveDuration = config.waves.duration;
            gameState.bossSpawned = false;
            gameState.score = 0;
            gameState.kills = 0;
            gameState.lifeStealKills = 0;
            gameState.shootTimer = 0;
            gameState.phase = 'playing';
            
            gameState.activeEffects = {
                fireball: false,
                ice: false,
                lightning: false,
                tornado: { active: false, timer: 0, x: 0, y: 0, lifetime: 0 },
                shield: { active: false, timer: 0 }
            };
            
            updateHealthUI();
            updateWaveUI();
            updateScoreUI();
            
            document.getElementById('card-modal').classList.remove('active');
            document.getElementById('death-screen').classList.remove('active');
        }

        // ===== GAME LOOP =====
        function gameLoop(timestamp) {
            const deltaTime = Math.min((timestamp - lastTime) / 1000, 0.11);
            lastTime = timestamp;

            if (currentMode === 'play' && gameState.phase === 'playing') {
                updateGame(deltaTime);
            }
            
            renderGame();
            
            animationId = requestAnimationFrame(gameLoop);
        }

        function updateGame(dt) {
            // Update player
            updatePlayer(dt);
            
            // Update shooting
            updateShooting(dt);
            
            // Update projectiles
            updateProjectiles(dt);
            
            // Update enemies
            updateEnemies(dt);
            
            // Update effects
            updateEffects(dt);
            
            // Update wave
            updateWave(dt);
            
            // Check collisions
            checkCollisions();
        }

        function updatePlayer(dt) {
            const player = gameState.player;
            let moveX = 0;
            let moveY = 0;
            
            // Keyboard input
            if (gameState.input.keys['w'] || gameState.input.keys['arrowup']) moveY -= 1;
            if (gameState.input.keys['s'] || gameState.input.keys['arrowdown']) moveY += 1;
            if (gameState.input.keys['a'] || gameState.input.keys['arrowleft']) moveX -= 1;
            if (gameState.input.keys['d'] || gameState.input.keys['arrowright']) moveX += 1;
            
            // Joystick input
            if (gameState.input.joystick.active) {
                moveX = gameState.input.joystick.x;
                moveY = gameState.input.joystick.y;
            }
            
            // Normalize diagonal movement
            const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
            if (magnitude > 0) {
                moveX /= magnitude;
                moveY /= magnitude;
            }
            
            // Acceleration/Deceleration with easing
            const acceleration = 1200; // pixels/s
            const deceleration = 800; // pixels/s (friction)
            const maxSpeed = gameState.stats.moveSpeed * gameState.stats.speedMultiplier;
            
            if (magnitude > 0.1) {
                // Accelerate toward target velocity
                const targetVx = moveX * maxSpeed;
                const targetVy = moveY * maxSpeed;
                
                // Ease acceleration
                const accelX = Math.sign(targetVx - player.vx) * acceleration;
                const accelY = Math.sign(targetVy - player.vy) * acceleration;
                
                player.vx += accelX * dt;
                player.vy += accelY * dt;
                
                // Clamp to max speed
                const currentSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                if (currentSpeed > maxSpeed) {
                    const scale = maxSpeed / currentSpeed;
                    player.vx *= scale;
                    player.vy *= scale;
                }
            } else {
                // Decelerate with friction
                const currentSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
                if (currentSpeed > 0) {
                    const decelX = Math.sign(player.vx) * deceleration;
                    const decelY = Math.sign(player.vy) * deceleration;
                    
                    player.vx -= decelX * dt;
                    player.vy -= decelY * dt;
                    
                    // Stop if nearly stopped
                    if (Math.abs(player.vx) < 10) player.vx = 0;
                    if (Math.abs(player.vy) < 10) player.vy = 0;
                }
            }
            
            // Apply movement
            player.x += player.vx * dt;
            player.y += player.vy * dt;
            
            // Clamp to arena bounds
            const halfSize = player.size / 2;
            player.x = Math.max(halfSize, Math.min(ARENA_WIDTH - halfSize, player.x));
            player.y = Math.max(halfSize, Math.min(ARENA_HEIGHT - halfSize, player.y));
            
            // Update rotation based on movement
            if (magnitude > 0.1) {
                player.rotation = Math.atan2(moveY, moveX);
            }
            
            // Add subtle hover motion (bobbing effect)
            if (!player.hoverTime) player.hoverTime = 0;
            player.hoverTime += dt;
            player.hoverOffset = Math.sin(player.hoverTime * 2) * 3; // 3px amplitude, 2 rad/s frequency
        }

        function updateShooting(dt) {
            gameState.shootTimer += dt;
            const shootInterval = 1 / gameState.stats.attackSpeed;
            
            if (gameState.shootTimer >= shootInterval) {
                gameState.shootTimer = 0;
                
                // Find nearest enemy
                const target = findNearestEnemy();
                if (target) {
                    shootProjectiles(target);
                    playSound('shoot_sound');
                }
            }
        }

        function findNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;
            
            for (const enemy of gameState.enemies) {
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }
            
            return nearest;
        }

        function shootProjectiles(target) {
            const player = gameState.player;
            const count = gameState.stats.projectileCount;
            const baseAngle = Math.atan2(target.y - player.y, target.x - player.x);
            
            if (count === 1) {
                createProjectile(player.x, player.y, baseAngle);
            } else {
                const spreadAngle = Math.PI / 6; // 30 degrees total spread
                const angleStep = spreadAngle / (count - 1);
                const startAngle = baseAngle - spreadAngle / 2;
                
                for (let i = 0; i < count; i++) {
                    const angle = startAngle + angleStep * i;
                    createProjectile(player.x, player.y, angle);
                }
            }
        }

        function createProjectile(x, y, angle) {
            const speed = 500;
            gameState.projectiles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: 8,
                damage: gameState.stats.damage * gameState.stats.damageMultiplier,
                hasIce: gameState.activeEffects.ice,
                hasLightning: gameState.activeEffects.lightning,
                hasChained: false
            });
        }

        function updateProjectiles(dt) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                proj.x += proj.vx * dt;
                proj.y += proj.vy * dt;
                
                // Remove if out of bounds
                if (proj.x < -50 || proj.x > ARENA_WIDTH + 50 || 
                    proj.y < -50 || proj.y > ARENA_HEIGHT + 50) {
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        function updateEnemies(dt) {
            const config = window.gameConfig;
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Move toward player
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    let speed = enemy.baseSpeed;
                    if (enemy.slowTimer > 0) {
                        speed *= 0.7; // 30% slow
                        enemy.slowTimer -= dt;
                    }
                    
                    enemy.vx = (dx / dist) * speed;
                    enemy.vy = (dy / dist) * speed;
                    enemy.x += enemy.vx * dt;
                    enemy.y += enemy.vy * dt;
                    enemy.rotation = Math.atan2(dy, dx);
                }
                
                // Remove if dead
                if (enemy.health <= 0) {
                    gameState.enemies.splice(i, 1);
                    gameState.kills++;
                    gameState.lifeStealKills++;
                    gameState.score += enemy.isBoss ? 500 : (enemy.type === 'large' ? 50 : enemy.type === 'medium' ? 20 : 10);
                    
                    playSound(enemy.isBoss ? 'boss_death_sound' : 'enemy_death_sound');
                    createExplosionEffect(enemy.x, enemy.y, enemy.color);
                    
                    // Life steal check
                    if (gameState.lifeStealKills >= 10) {
                        gameState.lifeStealKills = 0;
                        gameState.player.health = Math.min(gameState.player.health + 5, gameState.player.maxHealth);
                        updateHealthUI();
                    }
                    
                    updateScoreUI();
                }
            }
        }

        function updateEffects(dt) {
            // Tornado effect
            if (gameState.activeEffects.tornado.active) {
                gameState.activeEffects.tornado.timer += dt;
                
                if (gameState.activeEffects.tornado.timer >= 20) {
                    gameState.activeEffects.tornado.timer = 0;
                    spawnTornado();
                }
                
                if (gameState.activeEffects.tornado.lifetime > 0) {
                    gameState.activeEffects.tornado.lifetime -= dt;
                    
                    // Kill small enemies in range
                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                        const enemy = gameState.enemies[i];
                        if (enemy.type === 'small') {
                            const dx = enemy.x - gameState.activeEffects.tornado.x;
                            const dy = enemy.y - gameState.activeEffects.tornado.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < 80) {
                                enemy.health = 0;
                            }
                        }
                    }
                }
            }
            
            // Shield regeneration
            if (gameState.activeEffects.shield.active && !gameState.activeEffects.shield.hasShield) {
                gameState.activeEffects.shield.timer += dt;
                if (gameState.activeEffects.shield.timer >= 30) {
                    gameState.activeEffects.shield.timer = 0;
                    gameState.activeEffects.shield.hasShield = true;
                }
            }
            
            // Visual effects
            for (let i = gameState.effects.length - 1; i >= 0; i--) {
                const effect = gameState.effects[i];
                effect.lifetime -= dt;
                effect.scale += dt * 2;
                effect.alpha -= dt * 2;
                
                if (effect.lifetime <= 0) {
                    gameState.effects.splice(i, 1);
                }
            }
        }

        function spawnTornado() {
            gameState.activeEffects.tornado.x = Math.random() * ARENA_WIDTH;
            gameState.activeEffects.tornado.y = Math.random() * ARENA_HEIGHT;
            gameState.activeEffects.tornado.lifetime = 3;
            playSound('tornado_sound');
        }

        function updateWave(dt) {
            const config = window.gameConfig;
            
            if (gameState.waveTimer < gameState.waveDuration) {
                gameState.waveTimer += dt;
                
                // Spawn enemies
                const spawnRate = (1 + gameState.wave * 0.3) * config.waves.spawnRateMultiplier;
                if (Math.random() < spawnRate * dt) {
                    spawnEnemy();
                }
            } else if (!gameState.bossSpawned) {
                // Check if all regular enemies are dead
                if (gameState.enemies.length === 0) {
                    spawnBoss();
                    gameState.bossSpawned = true;
                }
            } else {
                // Check if boss is dead
                if (gameState.enemies.length === 0) {
                    endWave();
                }
            }
        }

        function spawnEnemy() {
            const config = window.gameConfig;
            const types = ['small', 'medium', 'large'];
            const weights = [0.6, 0.3, 0.1]; // Probability distribution
            
            let type = types[0];
            const rand = Math.random();
            let cumulative = 0;
            for (let i = 0; i < types.length; i++) {
                cumulative += weights[i];
                if (rand < cumulative) {
                    type = types[i];
                    break;
                }
            }
            
            const enemyConfig = config.enemies[type];
            const difficulty = 1 + (gameState.wave - 1) * config.waves.difficultyScaling;
            
            // Random spawn position on edge
            const edge = Math.floor(Math.random() * 4);
            let x, y;
            
            switch (edge) {
                case 0: // Top
                    x = Math.random() * ARENA_WIDTH;
                    y = -20;
                    break;
                case 1: // Right
                    x = ARENA_WIDTH + 20;
                    y = Math.random() * ARENA_HEIGHT;
                    break;
                case 2: // Bottom
                    x = Math.random() * ARENA_WIDTH;
                    y = ARENA_HEIGHT + 20;
                    break;
                case 3: // Left
                    x = -20;
                    y = Math.random() * ARENA_HEIGHT;
                    break;
            }
            
            gameState.enemies.push({
                x, y,
                vx: 0, vy: 0,
                type,
                health: enemyConfig.health * difficulty,
                maxHealth: enemyConfig.health * difficulty,
                baseSpeed: enemyConfig.speed,
                size: type === 'small' ? 16 : type === 'medium' ? 24 : 32,
                color: enemyConfig.color,
                rotation: 0,
                slowTimer: 0,
                isBoss: false
            });
        }

        function spawnBoss() {
            const config = window.gameConfig;
            const bossConfig = config.enemies.boss;
            const difficulty = 1 + (gameState.wave - 1) * config.waves.difficultyScaling;
            
            gameState.enemies.push({
                x: ARENA_WIDTH / 2,
                y: -50,
                vx: 0, vy: 0,
                type: 'boss',
                health: config.enemies.large.health * bossConfig.healthMultiplier * difficulty,
                maxHealth: config.enemies.large.health * bossConfig.healthMultiplier * difficulty,
                baseSpeed: bossConfig.speed,
                size: 48,
                color: bossConfig.color,
                rotation: 0,
                slowTimer: 0,
                isBoss: true
            });
        }

        function endWave() {
            playSound('wave_complete_sound');
            
            if (gameState.wave >= window.gameConfig.waves.count) {
                // Game won (endless mode, so just continue)
                gameState.wave++;
                startNextWave();
            } else {
                gameState.wave++;
                showCardSelection();
            }
        }

        function startNextWave() {
            gameState.waveTimer = 0;
            gameState.bossSpawned = false;
            gameState.phase = 'playing';
            updateWaveUI();
        }

        function checkCollisions() {
            // Projectiles vs Enemies
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dx = proj.x - enemy.x;
                    const dy = proj.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < proj.size + enemy.size) {
                        // Hit!
                        enemy.health -= proj.damage;
                        playSound('hit_sound');
                        
                        // Apply ice slow
                        if (proj.hasIce) {
                            enemy.slowTimer = 2;
                        }
                        
                        // Lightning chain
                        if (proj.hasLightning && !proj.hasChained) {
                            const nearbyEnemy = findNearbyEnemy(enemy, 150);
                            if (nearbyEnemy) {
                                const angle = Math.atan2(nearbyEnemy.y - enemy.y, nearbyEnemy.x - enemy.x);
                                const chainProj = {
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(angle) * 500,
                                    vy: Math.sin(angle) * 500,
                                    size: 8,
                                    damage: proj.damage * 0.5,
                                    hasIce: proj.hasIce,
                                    hasLightning: false,
                                    hasChained: true
                                };
                                gameState.projectiles.push(chainProj);
                            }
                        }
                        
                        gameState.projectiles.splice(i, 1);
                        break;
                    }
                }
            }
            
            // Enemies vs Player
            for (const enemy of gameState.enemies) {
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < enemy.size + gameState.player.size) {
                    // Hit player
                    if (gameState.activeEffects.shield.hasShield) {
                        gameState.activeEffects.shield.hasShield = false;
                        gameState.activeEffects.shield.timer = 0;
                    } else {
                        gameState.player.health -= 10;
                        playSound('player_hurt_sound');
                        updateHealthUI();
                        
                        if (gameState.player.health <= 0) {
                            gameOver();
                        }
                    }
                    
                    // Push enemy back
                    const pushAngle = Math.atan2(enemy.y - gameState.player.y, enemy.x - gameState.player.x);
                    enemy.x += Math.cos(pushAngle) * 20;
                    enemy.y += Math.sin(pushAngle) * 20;
                }
            }
        }

        function findNearbyEnemy(sourceEnemy, range) {
            for (const enemy of gameState.enemies) {
                if (enemy === sourceEnemy) continue;
                
                const dx = enemy.x - sourceEnemy.x;
                const dy = enemy.y - sourceEnemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < range) {
                    return enemy;
                }
            }
            return null;
        }

        function createExplosionEffect(x, y, color) {
            gameState.effects.push({
                x, y,
                color,
                lifetime: 0.5,
                scale: 1,
                alpha: 1
            });
        }

        // ===== CARD SELECTION =====
        function showCardSelection() {
            gameState.phase = 'card-selection';
            
            const config = window.gameConfig;
            const availableCards = Object.keys(SPELL_CARDS);
            
            // Randomly select cards
            const selectedCards = [];
            const cardCount = Math.min(config.spellCards.cardsPerWave, availableCards.length);
            
            while (selectedCards.length < cardCount && availableCards.length > 0) {
                const index = Math.floor(Math.random() * availableCards.length);
                selectedCards.push(availableCards[index]);
                availableCards.splice(index, 1);
            }
            
            // Display cards
            const cardGrid = document.getElementById('card-grid');
            cardGrid.innerHTML = '';
            
            for (const cardKey of selectedCards) {
                const card = SPELL_CARDS[cardKey];
                const cardEl = document.createElement('div');
                cardEl.className = 'spell-card';
                cardEl.style.borderColor = RARITY_COLORS[card.rarity];
                
                const icon = assetCache[card.icon];
                const iconEl = document.createElement('img');
                iconEl.className = 'card-icon';
                iconEl.src = icon ? icon.src : '';
                
                const nameEl = document.createElement('div');
                nameEl.className = 'card-name';
                nameEl.textContent = card.name;
                nameEl.style.color = RARITY_COLORS[card.rarity];
                
                const descEl = document.createElement('div');
                descEl.className = 'card-description';
                descEl.textContent = card.description;
                
                cardEl.appendChild(iconEl);
                cardEl.appendChild(nameEl);
                cardEl.appendChild(descEl);
                
                cardEl.addEventListener('click', () => {
                    selectCard(cardKey);
                });
                
                cardGrid.appendChild(cardEl);
            }
            
            document.getElementById('card-modal').classList.add('active');
        }

        function selectCard(cardKey) {
            playSound('card_select_sound');
            SPELL_CARDS[cardKey].apply();
            document.getElementById('card-modal').classList.remove('active');
            startNextWave();
        }

        // ===== GAME OVER =====
        function gameOver() {
            gameState.phase = 'game-over';
            
            document.getElementById('final-wave').textContent = gameState.wave;
            document.getElementById('final-kills').textContent = gameState.kills;
            document.getElementById('final-score').textContent = gameState.score;
            
            document.getElementById('death-screen').classList.add('active');
        }

        function restartGame() {
            initGame();
        }

        // ===== UI UPDATES =====
        function updateHealthUI() {
            const percent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('health-fill').style.width = percent + '%';
            document.getElementById('health-text').textContent = 
                `${Math.max(0, Math.floor(gameState.player.health))} / ${gameState.player.maxHealth}`;
        }

        function updateWaveUI() {
            document.getElementById('wave-text').textContent = `Wave ${gameState.wave}`;
        }

        function updateScoreUI() {
            document.getElementById('score-text').textContent = `Score: ${gameState.score}`;
        }

        // ===== RENDERING =====
        function renderGame() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            const bg = assetCache['castle_background'];
            if (bg) {
                // Cover scaling
                const bgAspect = bg.width / bg.height;
                const canvasAspect = ARENA_WIDTH / ARENA_HEIGHT;
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (bgAspect > canvasAspect) {
                    drawHeight = ARENA_HEIGHT;
                    drawWidth = drawHeight * bgAspect;
                    offsetX = (ARENA_WIDTH - drawWidth) / 2;
                    offsetY = 0;
                } else {
                    drawWidth = ARENA_WIDTH;
                    drawHeight = drawWidth / bgAspect;
                    offsetX = 0;
                    offsetY = (ARENA_HEIGHT - drawHeight) / 2;
                }
                
                ctx.drawImage(bg, offsetX, offsetY, drawWidth, drawHeight);
            }
            
            // Draw effects
            for (const effect of gameState.effects) {
                ctx.save();
                ctx.globalAlpha = effect.alpha;
                ctx.fillStyle = effect.color;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 20 * effect.scale, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw tornado
            if (gameState.activeEffects.tornado.lifetime > 0) {
                const tornado = gameState.activeEffects.tornado;
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.strokeStyle = '#88FF88';
                ctx.lineWidth = 4;
                
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const radius = 60 + i * 10;
                    ctx.arc(tornado.x, tornado.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }
            
            // Draw projectiles
            for (const proj of gameState.projectiles) {
                ctx.save();
                
                // Glow effect
                const gradient = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, proj.size * 2);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = proj.hasIce ? '#00FFFF' : (gameState.activeEffects.fireball ? '#FF8800' : '#00FFFF');
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            // Draw enemies
            for (const enemy of gameState.enemies) {
                const img = assetCache[enemy.isBoss ? 'enemy_boss' : `enemy_${enemy.type}`];
                if (img) {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.rotate(enemy.rotation);
                    
                    const size = enemy.size * 2;
                    const aspect = img.width / img.height;
                    let drawWidth, drawHeight;
                    
                    if (aspect > 1) {
                        drawWidth = size;
                        drawHeight = size / aspect;
                    } else {
                        drawHeight = size;
                        drawWidth = size * aspect;
                    }
                    
                    ctx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                    ctx.restore();
                    
                    // Health bar
                    if (enemy.health < enemy.maxHealth) {
                        const barWidth = enemy.size * 2;
                        const barHeight = 4;
                        const barY = enemy.y - enemy.size - 10;
                        
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.fillRect(enemy.x - barWidth / 2, barY, barWidth, barHeight);
                        
                        const healthPercent = enemy.health / enemy.maxHealth;
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(enemy.x - barWidth / 2, barY, barWidth * healthPercent, barHeight);
                    }
                }
            }
            
            // Draw player
            const playerImg = assetCache['player_character'];
            if (playerImg) {
                ctx.save();
                // Apply hover offset for floating effect
                const hoverY = gameState.player.y + (gameState.player.hoverOffset || 0);
                ctx.translate(gameState.player.x, hoverY);
                ctx.rotate(gameState.player.rotation);
                
                const size = gameState.player.size * 2;
                const aspect = playerImg.width / playerImg.height;
                let drawWidth, drawHeight;
                
                if (aspect > 1) {
                    drawWidth = size;
                    drawHeight = size / aspect;
                } else {
                    drawHeight = size;
                    drawWidth = size * aspect;
                }
                
                ctx.drawImage(playerImg, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                ctx.restore();
                
                // Shield effect
                if (gameState.activeEffects.shield.hasShield) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(gameState.player.x, hoverY, gameState.player.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        // ===== MAIN RUN FUNCTION =====
        function run(mode) {
            lib.log('run() called. Mode: ' + mode);
            currentMode = mode;
            
            // Setup canvas
            canvas.width = ARENA_WIDTH;
            canvas.height = ARENA_HEIGHT;
            
            // Show game parameters in edit mode
            if (mode === 'edit') {
                lib.showGameParameters({
                    name: 'Game Settings',
                    params: {
                        'Player Health': {
                            key: 'gameConfig.player.startHealth',
                            type: 'slider',
                            min: 50,
                            max: 200,
                            step: 10,
                            onChange: (value) => {
                                window.gameConfig.player.startHealth = value;
                            }
                        },
                        'Player Speed': {
                            key: 'gameConfig.player.moveSpeed',
                            type: 'slider',
                            min: 100,
                            max: 300,
                            step: 10,
                            onChange: (value) => {
                                window.gameConfig.player.moveSpeed = value;
                            }
                        },
                        'Attack Speed': {
                            key: 'gameConfig.player.attackSpeed',
                            type: 'slider',
                            min: 1,
                            max: 5,
                            step: 0.25,
                            onChange: (value) => {
                                window.gameConfig.player.attackSpeed = value;
                            }
                        },
                        'Base Damage': {
                            key: 'gameConfig.player.damage',
                            type: 'slider',
                            min: 5,
                            max: 20,
                            step: 1,
                            onChange: (value) => {
                                window.gameConfig.player.damage = value;
                            }
                        },
                        'Wave Count': {
                            key: 'gameConfig.waves.count',
                            type: 'slider',
                            min: 3,
                            max: 20,
                            step: 1,
                            onChange: (value) => {
                                window.gameConfig.waves.count = value;
                            }
                        },
                        'Wave Duration': {
                            key: 'gameConfig.waves.duration',
                            type: 'slider',
                            min: 20,
                            max: 60,
                            step: 5,
                            onChange: (value) => {
                                window.gameConfig.waves.duration = value;
                            }
                        },
                        'Spawn Rate': {
                            key: 'gameConfig.waves.spawnRateMultiplier',
                            type: 'slider',
                            min: 0.5,
                            max: 3,
                            step: 0.1,
                            onChange: (value) => {
                                window.gameConfig.waves.spawnRateMultiplier = value;
                            }
                        },
                        'Difficulty Scaling': {
                            key: 'gameConfig.waves.difficultyScaling',
                            type: 'slider',
                            min: 0.1,
                            max: 0.5,
                            step: 0.05,
                            onChange: (value) => {
                                window.gameConfig.waves.difficultyScaling = value;
                            }
                        }
                    }
                });
            }
            
            // Preload assets and start game
            preloadAssets().then(() => {
                setupInput();
                setupMainMenu();
                
                // Show main menu in play mode
                if (mode === 'play') {
                    document.getElementById('main-menu').classList.remove('hidden');
                } else {
                    // In edit mode, skip menu and go straight to game
                    document.getElementById('main-menu').classList.add('hidden');
                    initGame();
                    lastTime = performance.now();
                    gameLoop(lastTime);
                }
            });
        }
    </script>
</body>
</html>
