<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <title>Kaguya World 1.6.1</title>
    <link rel="icon" type="image/png" href="https://imgur.com/fheByI4.png">
    <style>
        body { margin: 0; padding: 0; background: #5c94fc; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        canvas { background: linear-gradient(to bottom, #5c94fc 0%, #92b9ff 100%); display: block; image-rendering: pixelated; }
        .ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; display: flex; flex-direction: column; gap: 15px; z-index: 10; }
        .stat-group { display: flex; flex-direction: column; gap: 5px; }
        .stat-row { display: flex; align-items: center; gap: 12px; font-size: 28px; font-weight: 900; text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000; }
        .icon { width: 40px; height: 40px; filter: drop-shadow(2px 2px 0px black); }
        .hp-bar-container { width: 250px; height: 20px; background: rgba(0, 0, 0, 0.7); border: 3px solid #000; border-radius: 5px; overflow: hidden; }
        .hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(to bottom, #ff3333, #880000); transition: width 0.2s ease; }
    </style>
</head>
<body>
    <div class="ui">
        <div class="stat-group">
            <div class="stat-row">
                <img src="https://imgur.com/7H8pFGh.png" class="icon" alt="vida">
                <span id="lifeText">LIFES = 3</span>
            </div>
            <div class="hp-bar-container">
                <div id="hpFill" class="hp-bar-fill"></div>
            </div>
        </div>
        <div class="stat-row">
            <span style="font-size: 40px;">ðŸ’¸</span>
            <span id="moneyText">MONEY = 0</span>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    const gravity = 0.9;
    const friction = 0.82;
    let keys = [];
    let cameraX = 0;
    let money = 0;
    let lastGeneratedX = 800;

    const imgIdle = new Image(); imgIdle.src = "https://imgur.com/urbofgF.png";
    const imgJump = new Image(); imgJump.src = "https://imgur.com/NW9NZBS.png";

    let player = {
        x: 100, y: 0, width: 135, height: 180, speed: 11,
        velX: 0, velY: 0, jumping: false, grounded: false,
        canDoubleJump: false, hp: 100, lives: 3, invincible: false,
        facing: "right"
    };

    let platforms = [{ x: 0, y: canvas.height - 200, width: 3000, height: 400 }];
    let collectibles = [];
    let enemies = [];

    function spawnProcedural(startX, endX) {
        for (let x = startX; x < endX; x += 700) {
            let platW = 600 + Math.random() * 500;
            let platH = 250 + Math.random() * 200;
            let platY = canvas.height - platH;
            platforms.push({ x: x, y: platY, width: platW, height: 1000 });
            collectibles.push({ x: x + platW/2, y: platY - 80, type: 'ðŸ’¸', value: 1 });
            if (Math.random() > 0.4) {
                enemies.push({ x: x + 150, y: platY - 70, width: 70, height: 70, speed: 4, emoji: "ðŸ¢", range: platW - 200, startX: x + 150 });
            }
        }
    }
    spawnProcedural(3000, 9000);

    function drawSMWPlatform(p) {
        ctx.fillStyle = "#a85020"; ctx.fillRect(p.x, p.y + 30, p.width, p.height);
        ctx.fillStyle = "#000"; ctx.fillRect(p.x, p.y + 30, p.width, 4);
        ctx.fillStyle = "#189828"; ctx.fillRect(p.x, p.y, p.width, 30);
        ctx.fillStyle = "#48f878"; ctx.fillRect(p.x, p.y, p.width, 8);
    }

    function colCheck(p, plat) {
        if (p.x + p.width > plat.x && p.x < plat.x + plat.width &&
            p.y + p.height > plat.y && p.y < plat.y + plat.height) {
            let overlapTop = (p.y + p.height) - plat.y;
            if (overlapTop < 50 && p.velY >= 0) {
                p.y = plat.y - p.height; p.velY = 0; p.grounded = true; p.jumping = false; p.canDoubleJump = false;
            }
        }
    }

    function update() {
        if (keys[39] || keys[68]) { player.velX = player.speed; player.facing = "right"; }
        else if (keys[37] || keys[65]) { player.velX = -player.speed; player.facing = "left"; }
        else { player.velX *= friction; }

        player.velY += gravity;
        player.grounded = false;
        platforms.forEach(p => colCheck(player, p));

        player.x += player.velX;
        player.y += player.velY;

        if (player.x + 3000 > lastGeneratedX) { spawnProcedural(lastGeneratedX, lastGeneratedX + 6000); lastGeneratedX += 6000; }
        cameraX += (player.x - canvas.width/4 - cameraX) * 0.1;

        ctx.save();
        ctx.translate(-cameraX, 0);

        platforms.forEach(p => drawSMWPlatform(p));

        enemies.forEach(en => {
            en.x += en.speed;
            if (en.x > en.startX + en.range || en.x < en.startX) en.speed *= -1;
            ctx.font = "70px Arial"; ctx.fillText(en.emoji, en.x, en.y + 60);
            if (Math.abs(player.x + player.width/2 - (en.x + 35)) < 80 && Math.abs(player.y + player.height/2 - (en.y + 30)) < 100) takeDamage(20);
        });

        // --- LÃ“GICA DE DESENHO CORRIGIDA (SEM FLICKER) ---
        // SÃ³ muda para imgJump se ela realmente estiver no ar (nÃ£o grounded)
        let currentImg = (!player.grounded) ? imgJump : imgIdle;
        
        ctx.save();
        if (player.invincible && Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.3;
        
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        
        // Decide a escala final
        let finalScaleX = (player.facing === "left") ? -1 : 1;
        // Se o sprite de pulo for invertido em relaÃ§Ã£o ao idle, descomente a linha abaixo:
        // if (currentImg === imgJump) finalScaleX *= -1; 
        
        ctx.scale(finalScaleX, 1);
        ctx.drawImage(currentImg, -player.width/2, -player.height/2, player.width, player.height);
        ctx.restore();
        ctx.restore();
    }

    function takeDamage(amount) {
        if (!player.invincible) {
            player.hp -= amount;
            if (player.hp <= 0) { player.lives--; player.hp = 100; if (player.lives <= 0) location.reload(); }
            document.getElementById("lifeText").innerText = "LIFES = " + player.lives;
            document.getElementById("hpFill").style.width = player.hp + "%";
            player.invincible = true;
            setTimeout(() => player.invincible = false, 1200);
        }
    }

    function loop() { ctx.clearRect(0, 0, canvas.width, canvas.height); update(); requestAnimationFrame(loop); }
    window.addEventListener("keydown", (e) => {
        if (!keys[e.keyCode] && (e.keyCode === 38 || e.keyCode === 32 || e.keyCode === 87)) {
            if (player.grounded) { player.velY = -26; player.grounded = false; player.canDoubleJump = true; }
            else if (player.canDoubleJump) { player.velY = -22; player.canDoubleJump = false; }
        }
        keys[e.keyCode] = true;
    });
    window.addEventListener("keyup", (e) => keys[e.keyCode] = false);
    loop();
</script>
</body>
</html>
